%!TEX root = ../dissertation.tex

\chapter{Data authentication in Galileo}

So far we've described the classic radio satellite navigation problem and
solution. This generally accepted model works well but provides no security
guarantees. In particular, it doesn't prevent malicious users to forge ad-hoc
signals and impersonate a satellite, or even a whole GNSS.

In this chapter we'll describe the general data authentication problem for open
signals in GNSS environments, the threat model and the possible attacks. We will
then move on to describe TESLA, a data authentication protocol suited for
streaming, lossy channels that the Galileo program chose to implement in order
to secure the navigation message. We'll also describe the proposed
implementation of TESLA in the current Galileo subframe structure.

% TOC
% - threat model
% - possible attacks
% - TESLA
% - ICD proposal to integrate TESLA in the current Galileo navigation message

\subsection{Initial key authentication}
The specification provided in \cite{tesla_gal} recommends for a single key chain
an extension of $2^{25}$ to $2^{26}$ keys. The actual duration of such a chain
is dependent on the key size, the number of satellites and the number of MACK
sections per subframe; with a key size of 82 bits, 36 satellites and 3 MACK
sections per subframe, the chain would have a duration of around 4 months.

Under these assumptions, we can try to analyze the scenario in which a receiver
with no prior navigation data starts to receive a navigation message inclusive
of DSM and verification tags, and subsequently tries to authenticate the
received key against the root key of the chain.

One hypothesis we make to analyze this scenario is that the key included in the
DSM-KROOT section is the key with index $0$. That is, the constellation doesn't
authenticate any other, more recent, key. This clarification is necessary since
the protocol specification declares the possibility of transmitting more recent
keys (i.e. with index higher than $0$) in the DSM, but doesn't provide any
detail on how that would work. To separate the two problems, we provide here a
worst-case analysis that's independent from the transmission of floating KROOTs.

\par

Having lined out the context, we can proceed on describing the set of operations
a receiver is required to perform in order to authenticate the navigation
message.

Let's assume the receiver already received and decoded a sufficient amount of
data to calculate the pseudorange against a satellite and to authenticate
mentioned data. This includes having at hand at least one MAC $t_m$, the key that
has been used to produce it $K_m$, and the root key $K_0$.

Given only this set of data, in order to authenticate the key $K_m$ the
receiver must perform precisely $m$ invocations of the one-way hashing function
$F$ in order to verify that $K_0 = F^m(K_m)$. At the end of the calculation, the
receiver will obtain $K_0' = F^m(K_m)$; if $K_0' = K_0$ (i.e. the calculated key
matches the one embedded in the DSM), then the authentication of $K_m$ is
successful. Otherwise, the key and associated data must be discarded.

We can then easily see that if a receiver starts to receive data at the end of a
key chain of length $L+1$, the initial key authentication will require applying
$L$ times the hash function to $K_L$.

\par

Starting from this result,
% Discussion points
% 1 the specs recommend for a chain to last 2^25/ - 2^26 keys. This means that a
%   receiver could receive its first frame of authenticated data close to the
%   end of the chain, and has to verify the key against the root key that is
%   close to 2^25 keys away. This means the receiver has to perform 2^25 hash
%   calculations before being sure the key is valid. It would be interesting to
%   know:
%   - how much time does this take with a normal processor?
%   - is there a more efficient way to handle the bootstrap process?
% 2 the specs point out the potential use of floating KROOTs. These require the
%   receiver to know the index of the key being transmitted. The specs don't
%   seem to specify how that is achieved
% 3 since the key chain is shared across satellites, to authenticate data for a
%   satellite a receiver must perform more than one hash calculation. It would
%   be interesting to analyze:
%   - upper bound on number of hash calculations a receiver must perform to
%     authenticate data from all satellites in view at a certain point in time
%   - guidelines on efficient handling of keys calculation and storage within a
%     subframe
%   - a more efficient alternative to this scheme
% 4 in scheme IV it's required that the sender sends along the interval index i,
%   the specs don't do this?
% 5 a possible DOS attack is to forge a packet marked as being from an interval
%   far in the future. A possible fix is to ignore packets if they could have
%   not been sent yet -> does a Galileo receiver have any means to do this? Any
%   condition on the fields that guarantees that this cannot happen?
% 6 local clocks of the sender and receiver don't drift too much during a
%   session -> client needs to know a loose upper bound on the maximum
%   synchronization error
% 7 with the authentication scheme, the receiver needs to cache data before it
%   can verify it: how much data needs to be cached?
% 8 in scheme IV at session setup the sender should send and authenticate the
%   starting time of the first interval, the duration of an interval and the
%   maximum delay d. The specs don't do this in full
% 9 the specs don't specify any value for the propagation delay. It would be
%   interesting to provide a recommended value
% 10 suggest that receivers initially synchronize time over the network before
%   starting to perform authentication with TESLA due to the protocol's
%   requirements? -> that would still be somehow insufficient, as it requires
%   the network time sync protocol is also authenticated
%     Or maybe the receiver can estimate an upper bound to the synchronization
%   error during the acquisition phase?
