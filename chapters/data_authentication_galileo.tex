%!TEX root = ../dissertation.tex

\chapter{Data authentication in Galileo}

So far we've described the classic radio satellite navigation problem and
solution. This generally accepted model works well but provides no security
guarantees. In particular, it doesn't prevent malicious users to forge ad-hoc
signals and impersonate a satellite, or even a whole GNSS.

In this chapter we'll describe the general data authentication problem for open
signals in GNSS environments, the threat model and the possible attacks. We will
then move on to describe TESLA, a data authentication protocol suited for
streaming, lossy channels that the Galileo program chose to implement in order
to secure the navigation message. We'll also describe the proposed
implementation of TESLA in the current Galileo subframe structure.

% TOC
% - threat model
% - possible attacks
% - TESLA
% - ICD proposal to integrate TESLA in the current Galileo navigation message

\subsection{Initial key authentication}
The specification provided in \cite{tesla_gal} recommends for a single key chain
an extension of $2^{25}$ to $2^{26}$ keys. The actual duration of such a chain
is dependent on the key size, the number of satellites and the number of MACK
sections per subframe; with a key size of 82 bits, 36 satellites and 3 MACK
sections per subframe, the chain would have a duration of around 4 months.

Under these assumptions, we can try to analyze the scenario in which a receiver
with no prior navigation data starts to receive a navigation message inclusive
of DSM and verification tags, and subsequently tries to authenticate the
received key against the root key of the chain.

One hypothesis we make to analyze this scenario is that the key included in the
DSM-KROOT section is the key with index $0$. That is, the constellation doesn't
authenticate any other, more recent, key. This clarification is necessary since
the protocol specification declares the possibility of transmitting more recent
keys (i.e. with index higher than $0$) in the DSM, but doesn't provide any
detail on how that would work. To separate the two problems, we provide here a
worst-case analysis that's independent from the transmission of floating KROOTs.

\par

Having lined out the context, we can proceed on describing the set of operations
a receiver is required to perform in order to authenticate the navigation
message.

Let's assume the receiver already received and decoded a sufficient amount of
data to calculate the pseudorange against a satellite and to authenticate
mentioned data. This includes having at hand at least one MAC $t_m$, the key that
has been used to produce it $K_m$, and the root key $K_0$.

Given only this set of data, in order to authenticate the key $K_m$ the
receiver must perform precisely $m$ invocations of the one-way hashing function
$F$ in order to verify that $K_0 = F^m(K_m)$. At the end of the calculation, the
receiver will obtain $K_0' = F^m(K_m)$; if $K_0' = K_0$ (i.e. the calculated key
matches the one embedded in the DSM), then the authentication of $K_m$ is
successful. Otherwise, the key and associated data must be discarded.

We can then easily see that if a receiver starts to receive data at the end of a
key chain of length $L+1$, the initial key authentication will require applying
$L$ times the hash function to $K_L$.

\par

Following this result, we've tried to perform a benchmark to understand time and
resource consumption in the best and worst case, to aid hardware design and
implementation for receivers that should support OSNMA.

The algorithm described so far contains three degrees of freedom that have been
analyzed separately: chain length, key length and selected hash function. As
stated, the recommended chain length is between $2^{25}$ and $2^{26}$; to
provide a more extensive overview our benchmark ranges between $2^{20}$ and
$2^{30}$ keys. The options for key length are fixed and provided in the
\textit{Key Size} included in the DSM-KROOT; these range between $80$ and $256$.
The possible hash functions are SHA256, SHA3-224 and SHA3-256.

Since the low availability of open source libraries that support SHA3 at the
time of writing, we've chosen to perform the benchmarking using \textbf{Python
3.6}. Since this dynamic language is not as performant as the best C
implementation attainable, we also provide a comparison between the two against
the time it takes to perform $2^{20}$ computations of a SHA256 chain.

% TODO Graphs and explanation here

One important aspect to focus our attention on is the relative significance of
this benchmark with respect to the average computation power of an average
receiver. The numbers just described have been obtained by running the code on a
MacBook Pro sporting a 2.6GHz Intel Core i5 processor. A benchmark sheet such as
\cite{bm_intel_core_i5} can show that such a processor can handle roughly $50k$
DMIPS. As a reference, the STA8088EXG GNSS receiver \cite{st_rec_specs} sports
an ARM9 processor clocking at a maximum of 208MHz. Usually in such receivers the
CPU clocks at much lower rates than their maximum (see for example
\cite{mediatek_specs}). According to the knowledge base of ARM, the maximum
performance of the ARM9 family reaches $1.1$ DMIPS per MHz, which means we can
assume the reference CPU can achieve roughly $230$ DMIPS.


chain length vs time (key length = 80)
SHA256
20 1.444907307624817
21 2.8077317237854005
22 5.58719539642334
23 11.18904983997345
24 22.408271765708925
25 44.85738096237183
26 89.83879985809327
27 179.4590810775757
28 359.1594285964966
29 855.2702621459961
30 1442.6938917398452

chain length vs time (key length = 80)
SHA3-256
20 1.1296464681625367
21 2.276822090148926
22 4.706751871109009
23 9.091611504554749
24 18.170960974693298
25 40.316378116607666
26 97.7468166589737
27 154.51102764606475

key size vs time (1 hash calculation)
80 1.4059744119644164
81 1.405664896965027
82 1.4987003087997437
83 1.4036413192749024
84 1.4075119256973267
85 1.4105588674545289
86 1.4008177042007446
87 1.397078776359558
88 1.4030397891998292
89 1.3949919939041138
90 1.3996456146240235
91 1.397261619567871
92 1.3923748016357422
93 1.394720482826233
94 1.3946498870849608
95 1.3986160516738892
96 1.3933444023132324
97 1.4055712223052979
98 1.397511076927185
99 1.3990198373794556
100 1.4038256883621216
101 1.3981321096420287
102 1.4061654806137085
103 1.6618628978729248
104 1.4377073049545288
105 1.4073763847351075
106 1.4142780303955078
107 1.4130674123764038
108 1.4132798194885254
109 1.404220175743103
110 1.4124313354492188
111 1.4178369045257568
112 1.4123440265655518
113 1.4100327014923095
114 1.4076751470565796
115 1.419326400756836
116 1.4141973495483398
117 1.41055908203125
118 1.4070046186447143
119 1.405657911300659
120 1.4082637071609496
121 1.4138463735580444
122 1.4063633918762206
123 1.4072680234909059
124 1.4075438022613525
125 1.4059937238693236
126 1.4032502174377441
127 1.4078078508377074
128 1.4007112741470338
129 1.4097970724105835
130 1.4158589839935303
131 1.4051631927490233
132 1.4067839860916138
133 1.4089675664901733
134 1.4109451055526734
135 1.4125774145126342
136 1.413805603981018
137 1.4106983184814452
138 1.4109532356262207
139 1.4106937885284423
140 1.4161378383636474
141 1.4104059219360352
142 1.4149670124053955
143 1.4004473686218262
144 1.4709396362304688
145 1.4065273523330688
146 1.4080482482910157
147 1.3999437808990478
148 1.407360553741455
149 1.406374168395996
150 1.4076793432235717
151 1.4067444801330566
152 1.398897409439087
153 1.4061072587966919
154 1.4101258993148804
155 1.410922145843506
156 1.4044927835464478
157 1.4137585639953614
158 1.4045366764068603
159 1.4129543066024781
160 1.4141073942184448
161 1.4067419528961183
162 1.4084864854812622
163 1.4111220359802246
164 1.4063573122024535
165 1.403774666786194
166 1.411686396598816
167 1.4100574016571046
168 1.403512454032898
169 1.4192238807678224
170 1.404030680656433
171 1.6855960130691527
172 1.4185676574707031
173 1.407211971282959
174 1.414251184463501
175 1.4058605670928954
176 1.4036326646804809
177 1.4076393127441407
178 1.4104631423950196
179 1.4144098520278932
180 1.4380284070968627
181 1.4133650302886962
182 1.4081059455871583
183 1.5393043279647827
184 1.5806415319442748
185 1.5800448179244995
186 1.621441864967346
187 1.6088290214538574
188 1.6197285890579223
189 1.616908812522888
190 1.6264840364456177
191 1.618447756767273
192 1.6219737768173217
193 1.6274790048599244
194 1.628587794303894
195 1.6201641321182252
196 1.6228398323059081
197 1.6212825298309326
198 1.6164492130279542
199 1.6294843912124635
200 1.6266362190246582
201 1.6236324548721313
202 1.6285581827163695
203 1.613469409942627
204 1.619645857810974
205 1.6220574855804444
206 1.623715329170227
207 1.6100627183914185
208 1.620134949684143
209 1.6200271606445313
210 1.610824704170227
211 1.6110652208328247
212 1.6189620971679688
213 1.6154519081115724
214 1.6335293769836425
215 1.6121753931045533
216 1.632153367996216
217 1.629298996925354
218 1.6252876758575439
219 1.6262574672698975
220 1.6187856435775756
221 1.6199545383453369
222 1.618445920944214
223 1.6271202087402343
224 1.6242397546768188
225 1.6242862939834595
226 1.6278365850448608
227 1.6186491966247558
228 1.6143537044525147
229 1.620882225036621
230 1.626295256614685
231 1.630773401260376
232 1.6356189966201782
233 1.6282888412475587
234 1.6280726194381714
235 1.621458387374878
236 1.6245858669281006
237 1.627734327316284
238 1.6248122215270997
239 2.013072299957275
240 1.678048014640808
241 1.6252437114715577
242 1.6381996631622315
243 1.6253415584564208
244 1.6307643890380858
245 1.6344199895858764
246 1.621861505508423
247 1.6333442687988282
248 1.6263067960739135
249 1.6326990127563477
250 1.6254504203796387
251 1.62477867603302
252 1.6287342309951782
253 1.6350444078445434
254 1.650987696647644
255 1.6243955373764039
256 1.6317465782165528

% Discussion points
% 1 the specs recommend for a chain to last 2^25/ - 2^26 keys. This means that a
%   receiver could receive its first frame of authenticated data close to the
%   end of the chain, and has to verify the key against the root key that is
%   close to 2^25 keys away. This means the receiver has to perform 2^25 hash
%   calculations before being sure the key is valid. It would be interesting to
%   know:
%   - how much time does this take with a normal processor?
%   - is there a more efficient way to handle the bootstrap process?
% 2 the specs point out the potential use of floating KROOTs. These require the
%   receiver to know the index of the key being transmitted. The specs don't
%   seem to specify how that is achieved
% 3 since the key chain is shared across satellites, to authenticate data for a
%   satellite a receiver must perform more than one hash calculation. It would
%   be interesting to analyze:
%   - upper bound on number of hash calculations a receiver must perform to
%     authenticate data from all satellites in view at a certain point in time
%   - guidelines on efficient handling of keys calculation and storage within a
%     subframe
%   - a more efficient alternative to this scheme
% 4 in scheme IV it's required that the sender sends along the interval index i,
%   the specs don't do this?
% 5 a possible DOS attack is to forge a packet marked as being from an interval
%   far in the future. A possible fix is to ignore packets if they could have
%   not been sent yet -> does a Galileo receiver have any means to do this? Any
%   condition on the fields that guarantees that this cannot happen?
% 6 local clocks of the sender and receiver don't drift too much during a
%   session -> client needs to know a loose upper bound on the maximum
%   synchronization error
% 7 with the authentication scheme, the receiver needs to cache data before it
%   can verify it: how much data needs to be cached?
% 8 in scheme IV at session setup the sender should send and authenticate the
%   starting time of the first interval, the duration of an interval and the
%   maximum delay d. The specs don't do this in full
% 9 the specs don't specify any value for the propagation delay. It would be
%   interesting to provide a recommended value
% 10 suggest that receivers initially synchronize time over the network before
%   starting to perform authentication with TESLA due to the protocol's
%   requirements? -> that would still be somehow insufficient, as it requires
%   the network time sync protocol is also authenticated
%     Or maybe the receiver can estimate an upper bound to the synchronization
%   error during the acquisition phase?
% 11 key size, MACK section length and MAC size are all provided in the
%    initial blocks of a DSM-KROOT. These are needed by the receiver in order to be
%    able to successfully decode the MACK sections. The problem here is that the
%    DSM-KROOT is transmitted at a way lower rate than the MACK section. It would
%    be interesting to:
%     - describe the worst case delay until a receiver can start authenticate
%       data
%     - provide a suggestion on how a receiver should implement different
%       stages: one in which it receives the operational parameters, one in
%       which it can receive/decode in parallel a DSM-KROOT and the MACKs, and
%       ome in which it can also authenticate the data
