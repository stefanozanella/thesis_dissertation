%!TEX root = ../dissertation.tex

\chapter{Data authentication in Galileo}

So far we've described the classic radio satellite navigation problem and
solution. This generally accepted model works well but provides no security
guarantees. In particular, it doesn't prevent malicious users to forge ad-hoc
signals and impersonate a satellite, or even a whole GNSS.

In this chapter we'll describe the general data authentication problem for open
signals in GNSS environments, the threat model and the possible attacks. We will
then move on to describe TESLA, a data authentication protocol suited for
streaming, lossy channels that the Galileo program chose to implement in order
to secure the navigation message. We'll also describe the proposed
implementation of TESLA in the current Galileo subframe structure.

\section{TESLA}
Certain characteristics of the Galileo signal make the problem of authenticating
the data very peculiar. Among others:
\begin{itemize}
  \item communication is unidirectional, from satellite to receiver(s)
  \item receivers can connect at any point in time
  \item the channel is lossy and doesn't guarantee data delivery
  \item communication happen on a very low-speed channel
\end{itemize}
The first three traits make it easier to associate the Galileo signal to a
multicast streaming communication. For this kind of communication, two schemes
have been proposed in \cite{perrig}. One of them, TESLA, offers authentication
of the sender with a minimal overhead, strong loss resistance and high
scalability, at the price of slightly delayed authentication. The second of
them, EMSS, adds non-repudiation on top of those features. The Galileo
commission chose to implement TESLA, and therefore we'd now put our focus on it.

\par

As an overview, TESLA builds on top of classic asymmetric authentication schemes
and MAC for data authentication. What TESLA does is to authenticate the data it
sends and to disclose the key that authenticated that data in a later packet.
Moreover, keys are connected with each other by using a key generation function
that takes a previous key as input. To account for different reception speeds,
TESLA supports using multiple chains, each with a different validity time for a
single key.

In our overview of the algorithm, we'll first look at how a single key chain
works, and then extend the concept to multiple chains.

\par

We start from a stream of messages $M_j$, each one sent after the other and
received in the same sequence. For each of these messages, TESLA computes a MAC
using a key $K_i$ and attaches it to the message. Moreover, TESLA attaches to
the same message the key it used to authenticate a previous message
$M_{j-\delta}$, where $\delta$ is a parameter called \textit{disclosure lag},
chosen so that it's guaranteed that every receiver received $M_{j-\delta}$ by
the time $M_j$ is sent out. This is referred as the \textit{security condition}
of the TESLA protocol, and it means that there's no chance for an attacker to
read $M_j$, tamper $M_{j-\delta}$ and have the latter accepted by a receiver.

Since keys are disclosed in clear, TESLA provides a way to verify that the key
is authentic by using other keys in the chain, plus a bootstrap mechanism. The
sender start by generating a random key $K_l$ that remains secret and that's
never used to sign any message. After this, the sender computes a chain of keys
by successively applying a one-way function $F$ to the keys in the chain:

\[
  K_i = F(K_{i+1})
\]

After $l$ steps, the chain is complete and the last application of $F$ yields
what's called a \textit{root key}:

\[
  K_0 = F^l(K_l)
\]

At this point the keys are broadcasted in reverse order than they're computed,
i.e. $K_0$ is sent before $K_1$, etc. This makes so that it's computationally
infeasible for an attacker to calculate $K_{i+1}$ given $K_i$ since $F$ is a
cryptographically secure one-way function. At the same time, once a receiver
receives $K_{i+1}$, it's easy for it to verify that the key $K_i$ is authentic,
as it needs to only apply $F$ to $K_{i+1}$ once and verify that the result is
$K_i$. The only requirement is that the root key is signed using a normal
asymmetric scheme during a bootstrap phase, so that receivers can verify that
the chain has been generated by the legitimate sender.

Another important aspect of TESLA is the use of the same key across several
messaeges. In fact, the validity of a key is not tied to a number of messages
but rather to an amount of time. This way the underlying streaming protocol can
have a variable streaming rate without increasing the overhead on the receiver's
side.

To give support to different types of receivers with different network access
speed, TESLA suggests the implementation of multiple simultaneous chains with
different disclosure periods $\delta$.

One important precondition that needs to be satisfied for the security condition
to hold is that sender and receivers have clocks that are roughly in sync within
a disclosure period (otherwise the security condition cannot be practically
verified).

\section{Galileo OSNMA}
In 2016, a specification for a data authentication protocol in Galileo has been
released under the name of OSNMA \cite{osnma}. This specification build on top
of the TESLA algorithm just described with a few notable exceptions. We'll give
here an introduction to this protocol to contextualize the analysis that
follows.
